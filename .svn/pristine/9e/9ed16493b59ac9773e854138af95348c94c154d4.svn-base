// pattern.cpp
//
// This sourcecode file is a part of embroidermodder.
// This program is free software; you can use, redistribute, and/or modify it
// under the terms of the GNU General Puplic License (GPL) as published by
// the Free Software Foundation.  See the file license.txt for details.
// http://embroidermodder.sourceforge.net/
//

#include "stdafx.h"
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <math.h>
#include "IEmbroideryReader.h"
#include "dst.cpp"
#include "csv.cpp"
#include "pcs.cpp"
#include "pes.cpp"
#include "exp.cpp"
#include "ksm.cpp"
#include "hus.cpp"
#include "pattern.h"
#include "helpers.h"
//#include "analyze.h"
//#include "paint.h"
#include "Messaging.h"
#include "EmbroideryDoc.h"
#include <algorithm>
using namespace std;


//number of stitches to allocate at a time
#define BLOCK_ALLOCATE_SIZE 1000

//////////////////////////////////////////////////////////////////////////
// pattern_config class
void pattern_config::clear() {
	scale=1.0;
	format=0;
};

//////////////////////////////////////////////////////////////////////////
// pattern class
void pattern::clear() {
	//clear out the pattern, but leave allocated space (except variable strings)
	int i;
	for(i=0; i<num_variables; i++) {
		delete(variable_name[i]);
		variable_name[i]=0;
		delete(variable_value[i]);
		variable_value[i]=0;
	};
	num_variables=0;
	stitches=0;
	colors=0;
	edit_stitch_num=0;
	messages.clear();
	config.clear();
};

pattern::~pattern() {	// desctructor
	clear();
	free(stitchlist);
	allocated_stitches=0;
	free(colorlist);
	allocated_colors=0;
	free(variable_name);
	free(variable_value);
	allocated_variables=0;
	if(messages.text_buffer_allocated!=0) free(messages.text_buffer);
	messages.text_buffer_allocated=0;
};

pattern::pattern () {	// constructor
	stitches=0;
	stitchlist=0;
	colors=0;
	num_variables=0;
	edit_stitch_num=0;

	allocated_stitches=BLOCK_ALLOCATE_SIZE;
	stitchlist = (struct stitch *)malloc(sizeof(struct stitch) * allocated_stitches);
	if (stitchlist==0) {
		fprintf(stderr,"ERROR: failed to alloc %d stitchlist bytes in initialize_pattern().\n",sizeof(struct stitch) * allocated_stitches);
		exit(-1);
	};

	allocated_colors=64;
	colorlist = (struct color*)malloc(sizeof(struct color) * allocated_colors);
	if (colorlist==0) {
		fprintf(stderr,"ERROR: failed to alloc %d color bytes in initialize_pattern().\n",sizeof(struct color) * allocated_colors);
		exit(-1);
	};
	allocated_variables=32;
	variable_name = (char **)malloc(sizeof(char *) * allocated_variables);
	variable_value = (char **)malloc(sizeof(char *) * allocated_variables);
	if (variable_name ==0 || variable_value==0) {
		fprintf(stderr,"ERROR: failed to alloc %d variable_name and variable_value pointers in initialize_pattern.\n",allocated_variables);
		exit(-1);
	};
};

void pattern::set_variable(const char *name, const char *value) {
	int i;
	if (name==0) {
		set_variable("",value); // recursively call with null string instead of null pointer
		return;
	};
	if (value==0) {
		set_variable(name,"");	// recursively call with null string instead of null pointer
		return;
	};
	for (i=0; i<num_variables;i++) {	// variable already defined?, replace the value
		if (_stricmp(variable_name[i],name)==0) {
			variable_value[i]=strrealloccopy(variable_value[i],value);
			return;
		};
	};									// variable not defined, add it
	if (num_variables>=allocated_variables) {
		allocated_variables+=32;		// allocate more space for lists of pointers
		variable_name=(char **)realloc(variable_name,sizeof(char *)*allocated_variables);
		variable_value=(char **)realloc(variable_value,sizeof(char *)*allocated_variables);
		if (variable_name ==0 || variable_value==0) {
			fprintf(stderr,"ERROR: failed to alloc %d variable_name and variable_value pointers in initialize_pattern.\n",allocated_variables);
			exit(-1);
		};
	};
	variable_name[num_variables]=stralloccopy(name);
	variable_value[num_variables]=stralloccopy(value);
	num_variables++;
};

char *pattern::get_variable(const char *name) const
{
	for (int i=0; i<num_variables;i++) 
	{
		if (_stricmp(variable_name[i],name)==0) 
		{
			return(variable_value[i]);
		};
	};
	return(NULL);
};

int pattern::get_variable_int(const char *name) const
{
	int value=0;
	char *val=get_variable(name);
	if (val!=0) 
	{
		value=atoi(val);
	};
	return(value);
};

double pattern::get_variable_double(const char *name) const
{
	double value=0.0;
	char *val=get_variable(name);
	if (val!=0) 
	{
		value=atof(val);
	};
	return(value);
};

void pattern::delete_variable(const char *name) 
{
	for (int i=0; i<num_variables;i++) 
	{
		if (_stricmp(variable_name[i],name)==0) 
		{
			free(variable_name[i]);
			free(variable_value[i]);
			num_variables--;
			for (;i<num_variables;i++) 
			{
				variable_name[i]=variable_name[i+1];
				variable_value[i]=variable_value[i+1];
			};
		};
	};
};

int pattern::AddColor(COLORREF rgb, const char *description, const char *catalog_number) 
{
	if (allocated_colors<colors+1) 
	{
		allocated_colors+=64;
		colorlist = (struct color *)realloc(colorlist, sizeof(struct color) * allocated_colors);
	};
	if (colorlist==0) {
		fprintf(stderr,"ERROR: failed to realloc %d bytes in AddColor().\n",sizeof(struct stitch) * allocated_stitches);
		exit(-1);
	};
	colorlist[colors].rgb=rgb;
	colorlist[colors].description=stralloccopy(description);
	colorlist[colors].catalog_number=stralloccopy(catalog_number);
	colors++;
	return(colors);
};

// Three routines to add a stitch to the pattern depending on format...
int pattern::AddStitchAbs(double x, double y, int flags, bool selected) 
{
	if (allocated_stitches<stitches+1) 
	{
		allocated_stitches+=BLOCK_ALLOCATE_SIZE;
		stitchlist = (struct stitch *)realloc(stitchlist, sizeof(struct stitch) * allocated_stitches);
	};
	if (stitchlist==0) {
		fprintf(stderr,"ERROR: failed to realloc %d bytes in AddStitchAbs().\n",sizeof(struct stitch) * allocated_stitches);
		exit(-1);
	};
	stitchlist[stitches].xx=x;
	stitchlist[stitches].yy=y;
	stitchlist[stitches].flags=flags;
	stitchlist[stitches].selected=selected;
	if (stitches==0) {
		stitchlist[stitches].color=0;
	} else {
		stitchlist[stitches].color=stitchlist[stitches-1].color;
		if (flags==STOP) stitchlist[stitches].color++;
	};
	stitches++;
	return(stitches);
};

int pattern::AddStitchRel (double dx, double dy, int flags, bool selected) 
{
	double x,y;
	if (stitches>0) {
		x = stitchlist[stitches-1].xx + dx;
		y = stitchlist[stitches-1].yy + dy;
	} else { // the list is empty so assume starting location is 0,0
		x = dx;
		y = dy;
	};
	return(AddStitchAbs(x,y,flags,selected));
};

int pattern::AddStitchCopy (struct stitch src, bool selected) 
{
	return(AddStitchAbs(src.xx,src.yy,src.flags,selected));
};

// Delete a stitch from the middle of the list.
int pattern::delete_stitch (int number) 
{
	int i;
	for (i=number; i<stitches; i++) {
		stitchlist[i]=stitchlist[i+1];
	};
	stitches--;

	// if we deleted a stitch before the current selection point, correct it.
	if (edit_stitch_num>number) edit_stitch_num--;
	return(stitches);
};

// Move a stitch from the end of the list to a position.
// To insert, add stitch normally, then move it to position.
// Note, the stitch changes color to match where it is inserted.
int pattern::move_last_stitch (int number) {
	int i;
	struct stitch temp;

	temp=stitchlist[stitches-1];
	for (i=stitches-1; i>number; i--) {
		stitchlist[i]=stitchlist[i-1];
	};
	stitchlist[number]=temp;

	// update color
	if (number==0) {
		stitchlist[number].color=0;
	} else {
		stitchlist[number].color=stitchlist[number-1].color;
	};
	return(stitches);
};

// Delete all selected stitches from the middle of the list.
int pattern::delete_selected (void) {
	int i,j;								// i is the write point, j is the read point.
	for (i=0,j=0; j<stitches; i++,j++) {		
		// advance read point until a non-selected stitch is found.
		for (;stitchlist[j].selected && j<stitches;j++);

		// move edit_stitch_num if we are moving or deleting it's stitch.
		if (edit_stitch_num>i && edit_stitch_num<=j) edit_stitch_num=i;

		if (j==stitches) break;

		if (i!=j) {			// move the next keep stitch at j to i
			stitchlist[i]=stitchlist[j];
		};
	};
	stitches = i;	// set the new pattern length

	return(stitches);
};

IEmbroideryReader *pattern::GetReaderByFileName(const char *filename)
{
	IEmbroideryReader *reader;
	CString extension = &filename[strlen(filename)-3];
	if (extension.CompareNoCase("dst")==0) {
		return new Dst();
	} else if (extension.CompareNoCase("csv")==0) {
		return new Csv();
	} else if (extension.CompareNoCase("pes")==0) {
		return new Pes();
	} else if (extension.CompareNoCase("pcs")==0) {
		return new Pcs();
	} else if (extension.CompareNoCase("exp")==0) {
		return new Exp();
	} else if (extension.CompareNoCase("ksm")==0) {
		return new Ksm();
	} else if (extension.CompareNoCase("hus")==0) {
		return new Hus();
	}
	return NULL;
}

BOOL pattern::Read(const char *filename)
{
	IEmbroideryReader *reader = GetReaderByFileName(filename);
	BOOL value = reader->Read(this,filename);
	free(reader);
	return value;
}

BOOL pattern::Write(const char *filename)
{
	IEmbroideryReader *reader = GetReaderByFileName(filename);
	BOOL value = reader->Write(this,filename);
	free(reader);
	return value;
}

// Very simple scaling of the x and y axis for every point.
// Doesn't insert or delete stitches to preserve density.
void pattern::scale_pattern (double scale) 
{
	for (int i=0;i<stitches;i++) 
	{
		stitchlist[i].xx=stitchlist[i].xx*scale;
		stitchlist[i].yy=stitchlist[i].yy*scale;
	};
};

void pattern::statistics(void) 
{
	int colors=1;
	int real_stitches=0;
	int jump_stitches=0;
	int unknown_stitches=0;
	double minx=0,maxx=0,miny=0,maxy=0;
	double min_stitchlength=999.0;
	double max_stitchlength=0.0;
	double total_stitchlength=0.0;
	int number_of_minlength_stitches=0;
	int number_of_maxlength_stitches=0;

	double xx=0,yy=0;
	double dx=0,dy=0;
	double length=0.0;

	if (stitches ==0) {
		messages.add("No design loaded\n");
		return;
	};

	for (int i=0;i<stitches;i++) {
		dx=stitchlist[i].xx-xx;
		dy=stitchlist[i].yy-yy;
		xx=stitchlist[i].xx;
		yy=stitchlist[i].yy;
		length=sqrt(dx * dx + dy * dy);
		if (i>0 && stitchlist[i-1].flags!=NORMAL) length=0.0;	//can't count first normal stitch;
		switch(stitchlist[i].flags) {
		case NORMAL:
			real_stitches++;
			if(length>max_stitchlength) {max_stitchlength=length; number_of_maxlength_stitches=0;};
			if(length==max_stitchlength) number_of_maxlength_stitches++;
			if(length>0 && length<min_stitchlength) 
			{
				min_stitchlength=length; 
				number_of_minlength_stitches=0;
			};
			if(length==min_stitchlength) number_of_minlength_stitches++;
			total_stitchlength+=length;
			if(xx<minx) minx=xx;
			if(xx>maxx) maxx=xx;
			if(yy<miny) miny=yy;
			if(yy>maxy) maxy=yy;
			break;
		case JUMP:
			jump_stitches++;
			break;
		case STOP:
			colors++;
			break;
		case END:
			break;
		default:
			unknown_stitches++;
			break;
		};
	};

	//second pass to fill bins now that we know max stitch length
#define NUMBINS 10
	int bin[NUMBINS+1];
	for (int i=0;i<=NUMBINS;i++) 
	{
		bin[i]=0;
	};

	for (int i=0;i<stitches;i++) {
		dx=stitchlist[i].xx-xx;
		dy=stitchlist[i].yy-yy;
		xx=stitchlist[i].xx;
		yy=stitchlist[i].yy;
		if (i>0 && stitchlist[i-1].flags==NORMAL && stitchlist[i].flags == NORMAL) {
			length=sqrt(dx * dx + dy * dy);
			bin[int(floor(NUMBINS*length/max_stitchlength))]++;
		};
	};

	char buf[1000];
	messages.clear();
	sprintf_s(buf,"Design name: %s\n",get_variable("design_name"));
	messages.add(buf);
	sprintf_s(buf,"Number of stitch entries: %d\n",stitches);
	messages.add(buf);
	sprintf_s(buf,"  Real stitches: %d\n",real_stitches);
	messages.add(buf);
	sprintf_s(buf,"  Jump stitches: %d\n",jump_stitches);
	messages.add(buf);
	sprintf_s(buf,"  Colors: %d\n",colors);
	messages.add(buf);
	sprintf_s(buf,"  Unknown stitches: %d\n",unknown_stitches);
	messages.add(buf);
	sprintf_s(buf,"Design width x height = %.1lf x %.1lf\n",maxx-minx,maxy-miny);
	messages.add(buf);
	sprintf_s(buf,"Center of design = %.1lf,%.1lf\n",(maxx+minx)/2.0,(maxy+miny)/2.0);
	messages.add(buf);
	sprintf_s(buf,"Total length of stitches: %.2lf\n",total_stitchlength);
	messages.add(buf);
	sprintf_s(buf,"Maximum stitch length: %.2lf (%d at this length)\n",max_stitchlength, number_of_maxlength_stitches);
	messages.add(buf);
	sprintf_s(buf,"Minimum stitch length: %.2lf (%d at this length)\n",min_stitchlength, number_of_minlength_stitches);
	messages.add(buf);
	sprintf_s(buf,"Average length of stitches: %.2lf\n",total_stitchlength/real_stitches);
	messages.add(buf);
	sprintf_s(buf,"Stitch length distribution:\n");
	messages.add(buf);
	for (int i=0;i<NUMBINS-1;i++) 
	{
		sprintf_s(buf," %6.2lf-%6.2lf == %d\n",i * max_stitchlength/NUMBINS,(i+1) * max_stitchlength/NUMBINS,bin[i]);
		messages.add(buf);
	};
	sprintf_s(buf," %6.2lf-%6.2lf == %d\n",(NUMBINS-1) * max_stitchlength/NUMBINS,NUMBINS * max_stitchlength/NUMBINS,bin[NUMBINS-1]+bin[NUMBINS]);
	messages.add(buf);

};

void pattern::create_test(void) {

	clear();
	set_variable("file_name","test7.csv");
	set_variable("design_name","TEST7");
	AddStitchAbs( 0.0, 0.0,JUMP);
	AddStitchAbs( 3.0, 3.0,JUMP);
	AddStitchAbs( 3.0, 3.0,NORMAL);
	AddStitchAbs(-3.0, 3.0,NORMAL);
	AddStitchAbs(-3.0,-3.0,NORMAL);
	AddStitchAbs( 3.0,-3.0,NORMAL);
	AddStitchAbs( 3.0, 3.0,NORMAL);
	AddStitchAbs(-3.0, 3.0,NORMAL);
	AddStitchAbs( 0.0, 0.0,JUMP);
	AddStitchAbs( 0.0, 0.0,END);
	AddColor(RGB(rand()%256,rand()%256,rand()%256),"Random","");
};

class lfRect pattern::get_select_bounds(int doc_selectmode) {
	class lfRect dim;
	int i; 
	double xx,yy;
	bool first=TRUE;
	// assumes 0 is somewhere in the pattern
	dim.top=dim.bottom=dim.left=dim.right=0;

	for (i=0;i<stitches;i++) {
		if (stitchlist[i].selected) {
			xx=stitchlist[i].xx;
			yy=stitchlist[i].yy;
			if (first) {
				dim.left= dim.right = xx;
				dim.top = dim.bottom= yy;
				first=FALSE;
			};
			if(xx<dim.left)   dim.left=xx;
			if(xx>dim.right)  dim.right=xx;
			if(yy>dim.top)    dim.top=yy;
			if(yy<dim.bottom) dim.bottom=yy;
			if ((doc_selectmode==DOC_SELECTMODE_LINES) && i>0 && (!stitchlist[i-1].selected)) {
				// linemode needs to include the point before this selected point 
				xx=stitchlist[i-1].xx;
				yy=stitchlist[i-1].yy;
				if(xx<dim.left)   dim.left=xx;
				if(xx>dim.right)  dim.right=xx;
				if(yy>dim.top)    dim.top=yy;
				if(yy<dim.bottom) dim.bottom=yy;
			};
		};
	};
	return (dim);
};

class lfRect pattern::get_dimensions(void) {
	class lfRect dim;
	double xx,yy;

	if (stitches==0) {
		// empty pattern, return a zero size rectangle
		dim.top=dim.bottom=dim.left=dim.right=0;
		return(dim);
	};
	// initialize with starting point
	dim.left=dim.right=stitchlist[0].xx;
	dim.top=dim.bottom=stitchlist[0].yy;

	for (int i=0;i<stitches;i++) {
		xx=stitchlist[i].xx;
		yy=stitchlist[i].yy;
		if(xx<dim.left)   dim.left=xx;
		if(xx>dim.right)  dim.right=xx;
		if(yy>dim.top)    dim.top=yy;
		if(yy<dim.bottom) dim.bottom=yy;
	};
	return (dim);
};

void pattern::calculate_angles(void) 
{
	double xx,yy,dx,dy;
	int flags;
	xx=yy=0.0;

	//	double pi = 3.1415926535;

	for (int i=0; i < stitches; i++) 
	{
		//initialize all to -999 to indicate invalid.
		stitchlist[i].a= -999;
		stitchlist[i].da=-999;
		stitchlist[i].l= -999;
	};

	for (int i=0; i < stitches; i++) 
	{
		dx=stitchlist[i].xx - xx;
		dy=stitchlist[i].yy - yy;
		xx=stitchlist[i].xx;
		yy=stitchlist[i].yy;
		flags=stitchlist[i].flags;
		stitchlist[i].l = sqrt(dx * dx + dy * dy); // length into this point

		if (flags!=JUMP) 
		{
			stitchlist[i].a = atan2(dy,dx) *180.0/pi;	// angle of line into this point
			if (stitchlist[i].l==0) 
			{
				stitchlist[i].a=-999;
			};
		};
	};
	for (int i=0; i < stitches-1; i++) 
	{
		if (stitchlist[i].a !=-999 && stitchlist[i+1].a !=-999) 
		{
			stitchlist[i].da = stitchlist[i+1].a-stitchlist[i].a;
		};
	};
};

int pattern::find_nearest_stitch (double x, double y, int doc_selectmode) {
	static int lastfound = -1;	// remember which was las found, to allow repeated calls to get a
	// different stitch if several at identical location.
	double nearestdistsqr;  // sqr of max allowed distance
	int nearestpt = -1;
	double distsqr;		// sqare of dist is less calculation than dist
	int i;
	double dx,dy;
	class lfRect dim;

	if (stitches ==0) return (-1);	// empty pattern
	if (lastfound >= stitches || lastfound <0) lastfound=stitches-1;

	// set max search radius based on 5% of pattern size
	dim=get_dimensions();
	dx=dim.width() * 0.05;
	dy=dim.height() * 0.05;
	nearestdistsqr = dx*dx+dy*dy;

	for (i=lastfound+1;;i++) {
		if (i>=stitches) i=0;	// wrap end of pattern
		if (doc_selectmode==DOC_SELECTMODE_POINTS) {
			dx=stitchlist[i].xx-x;
			dy=stitchlist[i].yy-y;
		} else /*DOC_SELECTMODE_LINES*/ {
			if (i>0) {
				dx=(stitchlist[i].xx+stitchlist[i-1].xx)/2-x;
				dy=(stitchlist[i].yy+stitchlist[i-1].yy)/2-y; 
			} else {
				dx=stitchlist[i].xx-x;
				dy=stitchlist[i].yy-y;
			};
		};
		distsqr=dx*dx+dy*dy;
		if (distsqr < nearestdistsqr) {
			nearestdistsqr=distsqr;
			nearestpt=i;
		};
		if (i==lastfound) break;
	};
	if (nearestpt!=-1) lastfound=nearestpt;
	return (nearestpt);
};

void pattern::clear_selection (void) 
{
	for (int i=0; i<stitches; i++) 
	{
		stitchlist[i].selected=FALSE;
	};
};

void pattern::select_all (void) 
{
	for (int i=0; i < stitches; i++) 
	{
		stitchlist[i].selected=TRUE;
	};
};

void pattern::select_color (int color) 
{
	int c=0;
	for (int i=0;i<stitches;i++) 
	{
		if (stitchlist[i].flags==STOP) c++;
		if (c==color) stitchlist[i].selected=TRUE;
	};
};

void pattern::select_stitch (int stitch, bool select) 
{
	if (stitch>=0 && stitch<stitches) 
	{
		stitchlist[stitch].selected=select;	// not a valid stitch number
	}
};

int pattern::CountSelected() 
{
	int count=0;
	for (int i=0; i < stitches; i++) 
	{
		if (stitchlist[i].selected) 
		{
			count++;
		}
	};
	return(count);
};

int pattern::get_color_of_stitch (int stitch) {
	int c=0;
	if (stitch<0 || stitch>=stitches) return (-1);	// not a valid stitch number
	for (int i=0; i < stitch; i++) 
	{
		if (stitchlist[i].flags==STOP) c++;
	};
	return (c);
};



void pattern::CalculateBoundingBox()
{
	// Calculate the bounding rectangle.  It's needed for smart repainting.
	if (stitches == 0)
	{
		BoundingRect = RECT();
		BoundingRect.bottom = 1;
		BoundingRect.right = 1;
		return;
	}
	stitch pt = stitchlist[0];

	BoundingRect = RECT();
	BoundingRect.left = (LONG)pt.xx;
	BoundingRect.right = (LONG)pt.xx;
	BoundingRect.top = (LONG)pt.yy;
	BoundingRect.bottom = (LONG)pt.yy;

	for (int i = 1; i < stitches; i++)
	{
		// If the point lies outside of the accumulated bounding
		// rectangle, then inflate the bounding rect to include it.
		pt = stitchlist[i];
		BoundingRect.left = (LONG)min(BoundingRect.left, pt.xx);
		BoundingRect.top = (LONG)min(BoundingRect.top, pt.yy);
		BoundingRect.right = (LONG)max(BoundingRect.right, pt.xx);
		BoundingRect.bottom = (LONG)max(BoundingRect.bottom, pt.yy);
	}
	return;
};

void pattern::InvertPatternVertical()
{
	for(int i = 0; i < stitches; i++)
	{
		stitchlist[i].yy = BoundingRect.bottom - BoundingRect.top - stitchlist[i].yy;
	}
};