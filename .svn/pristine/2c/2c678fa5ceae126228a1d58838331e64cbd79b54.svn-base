//helpers.cpp
//
// This sourcecode file is a part of embroidermodder.
// This program is free software; you can use, redistribute, and/or modify it
// under the terms of the GNU General Puplic License (GPL) as published by
// the Free Software Foundation.  See the file license.txt for details.
// http://embroidermodder.sourceforge.net/
//
#include "stdafx.h"
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <math.h>
#include "helpers.h"
#include "pattern.h"

char *stralloccopy (const char *src) {
	char *dest;
	dest = (char *)malloc(strlen(src)*(sizeof(char)+1));
	if (dest==0) {
		fprintf(stderr,"ERROR: malloc failed for %d bytes in stralloccopy(%s)\n",strlen(src)*sizeof(char),src);
		exit(-1);
	};
	strcpy(dest,src);
	return(dest);
};

char *strrealloccopy (char *old_dest, const char *src) {
	char *dest;
	dest = (char *)realloc(old_dest,strlen(src)*(sizeof(char)+1));
	if (dest==0) {
		fprintf(stderr,"ERROR: realloc failed for %d bytes in strrealloccopy(%s)\n",strlen(src)*sizeof(char),src);
		exit(-1);
	};
	strcpy(dest,src);
	return(dest);
};

char *flagstotext (int flags) {
	switch(flags) {
	case NORMAL:
		return("Normal Stitch");
		break;
	case END:
		return("End");
		break;
	case JUMP:
		return("Jump Stitch");
		break;
	case STOP:
		return("Stop/Color");
		break;
	default:
		return("Unknown");
		break;
	};
};

int round(double src) {
	return(int(floor(src+0.5)));
};


//===================================================================
// lfRect class functions

lfRect::lfRect(void) {
	left=top=right=bottom=0.0;
};
lfRect::lfRect(double l, double t, double r, double b) {
	left=l; top=t; right=r, bottom=b;
};
double lfRect::width(void) {
	return(right-left);
};
double lfRect::height(void) {
	return(top-bottom);
};
bool lfRect::isin(class lfVector pt) {
	// is point inside rectangle?
	// works even with non-normalized rectangle
	if (left < right) {
		if (pt.dx < left || pt.dx > right) return (FALSE);
	} else {
		if (pt.dx > left || pt.dx < right) return (FALSE);
	};
	if (top < bottom) {
		if (pt.dy < top || pt.dy > bottom) return (FALSE);
	} else {
		if (pt.dy > top || pt.dy < bottom) return (FALSE);
	};
	return (TRUE);
};
bool lfRect::doeslineintersect(class lfVector pta, class lfVector ptb) {
	// if both points are off the same side, then line cannot pass through rectangle.
	if (left < right) {
		if (pta.dx < left && ptb.dx < left) return (FALSE);
		if (pta.dx > right && ptb.dx > right) return (FALSE);
	} else {
		if (pta.dx > left && ptb.dx > left) return (FALSE);
		if (pta.dx < right && ptb.dx < right) return (FALSE);
	};
	if (top < bottom) {
		if (pta.dy < top && ptb.dy < top) return (FALSE);
		if (pta.dy > bottom && ptb.dy > bottom) return (FALSE);
	} else {
		if (pta.dy > top && ptb.dy > top) return (FALSE);
		if (pta.dy < bottom && ptb.dy < bottom) return (FALSE);
	};
	// include as TRUE the rare condition where line may go past a corner, but not completely in.
	// this condition would require additional calculation, and isn't that critical for clipping.

	return(TRUE);
};
CRect lfRect::round_rect(void) {
	return(CRect(round(left),round(top),round(right),round(bottom)));
};

//===================================================================
// lfVector class functions

lfVector::lfVector(double x,double y) {
	dx=x; dy=y;
};

lfVector::lfVector() {
	dx=0; dy=0;
};


double lfVector::a(void) {
	//	double pi = 3.1415926535;
	return(atan2(dy,dx)*(180/pi));
};

double lfVector::l(void) {
	return(sqrt(dx*dx + dy*dy));
};

double lfVector::slope(void) {
	return(dy/dx);
};

class lfVector lfVector::vector_rotate(double a) {
	double sina,cosa;
	double rada;
	//	double pi = 3.1415926535;
	rada=a*(pi/180.0);
	sina=sin(rada);
	cosa=cos(rada);
	return(lfVector(dx*cosa-dy*sina,dy*cosa+dx*sina));
};

class lfVector lfVector::operator *(double c) {
	return(lfVector(dx*c,dy*c));
};

//class lfVector lfVector::scale(double c) {
//	return(lfVector(dx*c,dy*c));
//};

//CPoint lfVector::scale(double c) {
//	return(CPoint(round(dx*c),round(dy*c)));
//};

CPoint lfVector::round_vector(void) {
	return(CPoint(round(dx),round(dy)));
};


char *split_cell_str(char *line, int field) {
	//returns a pointer to a string containging the cell at field number.
	//copy this for storage because temporary storage will be overwritten by 10th next call.
	unsigned int i,j;
	int f;
	static char buf[10][2048]; // 10 big static temporary buffers
	static int lastused=0;
	int quotemode=0;
	f=1;
	lastused++; lastused%=10; // choose a different buffer than last time
	for (i=0;i<strlen(line);i++) {
		if (f==field) break;
		if (line[i]=='"') quotemode=-quotemode+1; // toggle
		if (line[i]==',' && quotemode==0) f++;
		if (line[i]=='\n') return("");
	};
	// found the start of the cell
	for (j=0;i<strlen(line);i++,j++) {
		buf[lastused][j]=line[i];
		if (i>2047) break;
		if (buf[lastused][j]=='"') {
			quotemode=-quotemode+1; // toggle
			j--; // eat quote from output
		};
		if ((buf[lastused][j]==',' && quotemode==0) || buf[lastused][j]=='\n') break;
	};
	buf[lastused][j]='\0';
	return(buf[lastused]);
};

double split_cell_double(char *line, int field) {
	char *buf;
	double val;

	buf = split_cell_str(line,field);
	val = atof(buf);
	return(val);
};

int split_cell_int(char *line, int field) {
	char *buf;
	int val;

	buf = split_cell_str(line,field);
	val = atoi(buf);
	return(val);
};


//This class encapsulates the file read/write functions using MFC's CFile type or standard C' FILE type.
//It does this efficiently by creating a memory buffer
/*
class membuf_io {
unsigned char *buf;
int buf_allocated;
int pos;

*/