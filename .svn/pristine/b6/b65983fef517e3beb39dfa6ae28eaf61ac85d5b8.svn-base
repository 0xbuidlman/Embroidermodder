//dst.cpp
// .DST (Tajima) embroidery file read/write routines

// Format comments are thanks to tspilman@dalcoathletic.com who's
// notes appeared at http://www.wotsit.org under Tajima Format.

#include "stdafx.h"
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <math.h>
#include "dst.h"
#include "pattern.h"
#include "helpers.h"
//#include "paint.h"
#include "MainFrm.h"
#include "Messaging.h"

// Procedures

int getbit(unsigned char b, int pos) {
	int bit;
	bit = (b>>pos)&1;
	return (bit);
};

int decode_record_dx (char b0, char b1, char b2) {
	int x=0;
	x+= getbit(b2,2)*(+81);
	x+= getbit(b2,3)*(-81);
	x+= getbit(b1,2)*(+27);
	x+= getbit(b1,3)*(-27);
	x+= getbit(b0,2)*(+9);
	x+= getbit(b0,3)*(-9);
	x+= getbit(b1,0)*(+3);
	x+= getbit(b1,1)*(-3);
	x+= getbit(b0,0)*(+1);
	x+= getbit(b0,1)*(-1);
	return(x);
};

int decode_record_dy (char b0, char b1, char b2) {
	int y=0;
	y+= getbit(b2,5)*(+81);
	y+= getbit(b2,4)*(-81);
	y+= getbit(b1,5)*(+27);
	y+= getbit(b1,4)*(-27);
	y+= getbit(b0,5)*(+9);
	y+= getbit(b0,4)*(-9);
	y+= getbit(b1,7)*(+3);
	y+= getbit(b1,6)*(-3);
	y+= getbit(b0,7)*(+1);
	y+= getbit(b0,6)*(-1);
	return(y);
};

int decode_record_flags (unsigned char b2) {
	if (b2==243) return(END);
	switch (b2&195) {
		case 3:
			return(NORMAL);
		case 131:
			return(JUMP);
		case 195:
			return(STOP);
		default:
			return(UNKNOWN);
	};
};

unsigned char setbit(int pos) {
	return(1<<pos);
};

void encode_record (unsigned char *b, int x, int y, int flags) {
	char b0,b1,b2;
	b0=b1=b2=0;

	// cannot encode values > 121 or < -121.

	if (x>=+41) {b2+=setbit(2); x-=81;};
	if (x<=-41) {b2+=setbit(3); x+=81;};
	if (x>=+14) {b1+=setbit(2); x-=27;};
	if (x<=-14) {b1+=setbit(3); x+=27;};
	if (x>=+ 5) {b0+=setbit(2); x-= 9;};
	if (x<=- 5) {b0+=setbit(3); x+= 9;};
	if (x>=+ 2) {b1+=setbit(0); x-= 3;};
	if (x<=- 2) {b1+=setbit(1); x+= 3;};
	if (x>=+ 1) {b0+=setbit(0); x-= 1;};
	if (x<=- 1) {b0+=setbit(1); x+= 1;};
	if(x!=0) {
		//error
	};
	if (y>=+41) {b2+=setbit(5); y-=81;};
	if (y<=-41) {b2+=setbit(4); y+=81;};
	if (y>=+14) {b1+=setbit(5); y-=27;};
	if (y<=-14) {b1+=setbit(4); y+=27;};
	if (y>=+ 5) {b0+=setbit(5); y-= 9;};
	if (y<=- 5) {b0+=setbit(4); y+= 9;};
	if (y>=+ 2) {b1+=setbit(7); y-= 3;};
	if (y<=- 2) {b1+=setbit(6); y+= 3;};
	if (y>=+ 1) {b0+=setbit(7); y-= 1;};
	if (y<=- 1) {b0+=setbit(6); y+= 1;};
	if(y!=0) {
		//error
	};
	switch (flags) {
		case NORMAL:
			b2+=(char)3;
			break;
		case END:
			b2=(char)243;
			b0=b1=(char)0;
			break;
		case JUMP:
			b2+=(char)131;
			break;
		case STOP:
			b2+=(char)195;
			break;
		default:
			b2+=3;
			//fprintf(fout,"Unknown\n");
			break;
	};
	b[0]=b0;b[1]=b1;b[2]=b2;
};

int atorgb(char *val) {
	// expect string beginning with 6 hex digits
	int i;
	int rgb;
	rgb=0;
	for (i=0;i<6;i++) {
		if (val[i]>='0'&&val[i]<='9') {
			rgb=rgb*16+val[i]-'0';
		} else if (val[i]>='A'&&val[i]<='F') {
			rgb=rgb*16+val[i]-'A';
		} else if (val[i]>='a'&&val[i]<='f') {
			rgb=rgb*16+val[i]-'a';
		} else if (val[i]==','||val[i]=='\0') {
			// early delimiter
			break;
		} else {
			// unknown character
			break;
		};
	};
	return(rgb);
};

//convert 2 characters into 1 int for case statement
//#define cci(s) (s[0]*256+s[1])
#define cci(c1,c2) (c1*256+c2)
void set_dst_variable(class pattern *pattern, char *var, char *val) {
	unsigned int i;
	for(i=0;i<=strlen(var);i++) {		// upcase var
		if(var[i]>='a'&&var[i]<='z') var[i]+='A'-'a';
	}
	// macro converts 2 characters to 1 int, allows case statement...
	switch(cci(var[0],var[1])) {
	case cci('L','A'):	//Design Name (LA)
		pattern->set_variable("Design_Name",val);
		break;
	case cci('S','T'):	//Stitch count, 7 digits padded by leading 0's
	case cci('C','O'):	//Color change count, 3 digits padded by leading 0's
	case cci('+','X'):	//Design extents (+/-X,+/-Y), 5 digits padded by leading 0's
	case cci('-','X'):
	case cci('+','Y'):
	case cci('-','Y'):
		// don't store these variables, they are recalculated at save
		break;
	case cci('A','X'):	//Relative coordinates of last point, 6 digits, padded with leading spaces, first char may be +/-
	case cci('A','Y'):
	case cci('M','X'):	//Coordinates of last point in previous file of multi-volume design, 6 digits, padded with leading spaces, first char may be +/-
	case cci('M','Y'):
		// store these variables as-is, they will be converted to numbers and back at save;
		pattern->set_variable(var,val);
		break;
	case cci('P','D'):
		// store this string as-is, it will be saved as-is, 6 characters
		if (strlen(val)!=6) {
			buffer_add("Warning: in DST file read, PD is not 6 characters, but ",(int)strlen(val));
		};
		pattern->set_variable(var,val);
		break;
	// Begin extended fields section
	case cci('A','U'):	//Author string, arbitrary length
	case cci('C','P'):	//Copyright string, arbitrary length
		pattern->set_variable(var,val);
		break;
	case cci('T','C'):	//Thread Color: #RRGGBB,Description,Catalog Number (1st field RGB hex values, 2nd&3rd fields optional arbitrary length)
		//rgb=atorgb(val);
		//description=split_cell_str(val,2);
		//catalog_number=split_cell_str(val,3);
		pattern->add_color(atorgb(val),split_cell_str(val,2),split_cell_str(val,3));
		break;
	default:
		//unknown field, just save it.
		pattern->set_variable(var,val);
		break;
	};
};

void dst_read(class pattern *pattern, const char *filename) {
	CFile dstin;

	if (!dstin.Open(filename,CFile::modeRead)) {
		fprintf(stderr, "Error opening %s for read\n",filename);
		exit(-1);
	};

	dst_read(pattern,&dstin);

	dstin.Close();
};

void dst_read(class pattern *pattern, CFile *dstin) {
	char header[512+1];// The header seems to contain information about the design.
					// Seems to be ASCII text delimited by 0x0D (carriage returns).
					// This must be in the file for most new software or hardware
					// to consider it a good file!  This is much more important
					// than I originally believed.  The header is 125 bytes in
					// length and padded out by 0x20 to 512 bytes total.
					// All entries in the header seem to be 2 ASCII characters
					// followed by a colon, then it’s value trailed by a carriage
					// return.
//	char LA[16+1];	// First is the ‘LA’ entry, which is the design name with no
					// path or extension information.   The blank is 16 characters
					// in total, but the name must not be longer that 8 characters
					// and padded out with 0x20.
//	char ST[7+1];	// Next is the stitch count ST, this is a 7 digit number
					// padded by leading zeros.  This is the total stitch count
					// including color changes, jumps, nups, and special records.
//	char CO[3+1];	// Next, is CO or colors,  a 3 digit number padded by leading
					// zeros.  This is the number of color change records in the
					// file.
//	char POSX[5+1];	// Next is +X or the positive X extent in centimeters, a 5
					// digit non-decimal number padded by leading zeros.
//	char NEGX[5+1];	// Following is the -X or the negative X extent in millimeters,
					// a 5 digit non-decimal number padded by leading zeros.
//	char POSY[5+1];	// Again, the +Y extents.
//	char NEGY[5+1];	// Again, the -Y extents.

//	char AX[6+1];	// AX and AY should express the relative coordinates of the
//	char AY[6+1];	// last point from the start point in 0.1 mm.  If the start
					// and last points are the same, the coordinates are (0,0).
//	char MX[6+1];	// MX and MY should express coordinates of the last point of
//	char MY[6+1];	// the previous file for a multi-volume design.  A multi-
					// volume design means a design consisted of two or more files.
					// This was used for huge designs that can not be stored in a
					// single paper tape roll.  It is not used so much (almost
					// never) nowadays.
//	char PD[9+1];	// PD is also storing some information for multi-volume design.

//	FILE *dstin;
	int i;

	// for converting stitches from file encoding
	unsigned char b0,b1,b2;
	int dx,dy;
	int flags;

	//for calculating extents
//	int st,co,posx,negx,posy,negy;

	pattern->clear();
	pattern->set_variable("file_name",dstin->GetFileName());
//	dstin = fopen(filename,"r");
//	if (dstin==0) {
//		status("Error opening DST file for read:",filename);
//		buffer_add("Error opening DST file for read:",filename);
		//fprintf(stderr,"Error opening %s for read\n",filename);
		//exit(-1);
//		return;
//	};
//	_setmode( _fileno( dstin ), _O_BINARY ); 

	// READ 512 BYTE HEADER INTO header[]
	for (i=0;i<512;i++) {
		dstin->Read(&header[i],1);
		//header[i]=fgetc(dstin);
	};

	// TODO:It would probably be a good idea to validate file before accepting it.

	char var[3];	// temporary storage variable name
	char val[512];	// temporary storage variable value
	int valpos;
	// fill variables from header fields
	for (i=0;i<512;i++) {
		if (header[i]==':') {
			var[0]=header[i-2];
			var[1]=header[i-1];
			var[2]='\0';
			valpos=i+1;
			for (i++;i<512;i++) {
				if(header[i]==13||header[i]==':') { // 0x0d = carriage return
					if(header[i]==':') { // : indicates another variable, CR was missing!
						i-=2;
					};
					strncpy(val,&header[valpos],i-valpos);
					val[i-valpos]='\0';
					set_dst_variable(pattern,var,val);
					//pattern->set_variable(var,val);
					buffer_add(var,val);
					break;
				};
			};
		};
	};

	//pattern->set_variable("Design_Name", pattern->get_variable("LA"));	// copy LA into design_name
//	strncpy(LA,header+3,16);
//	strncpy(ST,header+23,7);
//	strncpy(CO,header+34,3);
//	strncpy(POSX,header+41,5);
//	strncpy(NEGX,header+50,5);
//	strncpy(POSY,header+59,5);
//	strncpy(NEGY,header+68,5);
//	strncpy(AX,header+77,6);
//	strncpy(AY,header+87,6);
//	strncpy(MX,header+97,6);
//	strncpy(MY,header+107,6);
	//strncpy(PD,header+117,9); //don't use this because...
//	for (i=0;i<9;i++) {		// PD is a binary string and may contain \0.
//		PD[i]=header[117+i];
//	};

	//add end of string delimiters and convert to numbers
//	LA[16]='\0';
//	pattern->initialize_pattern(LA,filename);
//	ST[7]='\0';
//	sscanf(ST,"%d",&st);
//	CO[3]='\0';
//	sscanf(CO,"%d",&co);
//	POSX[5]='\0';
//	sscanf(POSX,"%d",&posx);
//	NEGX[5]='\0';
//	sscanf(NEGX,"%d",&negx);
//	POSY[5]='\0';
//	sscanf(POSY,"%d",&posy);
//	NEGY[5]='\0';
//	sscanf(NEGY,"%d",&negy);
//	AX[6]='\0';
//	AY[6]='\0';
//	MX[6]='\0';
//	MY[6]='\0';
//	PD[9]='\0';

#ifdef DEBUG_FILEOUT
	FILE *fout;
	fout = fopen("stdout.txt","w");
	if (fout==0) {
		status("Error opening stdout.txt for writing in debug portion of dst_write.");
//		fprintf(stderr, "Error opening %s for write\n","stdout.txt");
//		exit(-1);
		return;
	};
	//Display header for debugging purposes
	fprintf(fout,"HEADER: (file %s)\n",filename);
	fprintf(fout," LA:%s\n",LA);
	fprintf(fout," ST:%s (%d)\n",ST,st);
	fprintf(fout," CO:%s (%d)\n",CO,co);
	fprintf(fout," +X:%s (%d)\n",POSX,posx);
	fprintf(fout," -X:%s (%d)\n",NEGX,negx);
	fprintf(fout," +Y:%s (%d)\n",POSY,posy);
	fprintf(fout," -Y:%s (%d)\n",NEGY,negy);
	fprintf(fout," AX:%s\n",AX);
	fprintf(fout," AY:%s\n",AY);
	fprintf(fout," MX:%s\n",MX);
	fprintf(fout," MY:%s\n",MY);
	fprintf(fout," PD:%s\n",PD);
	fprintf(fout,"\n");
	fprintf(fout,"Begin reading: %d stitches\n",st);
#endif
	buffer_add("Begin reading stitches:", pattern->get_variable("st"));

	int co=1;	// count number of colors
	//READ STITCH RECORDS
	for (i=0;dstin->GetLength()!=dstin->GetPosition();i++) {
		char buf[4];
		dstin->Read(buf,3);
		b0=buf[0];	//fgetc(dstin);
//		if (feof(dstin)) break;
		b1=buf[1];	//fgetc(dstin);
//		if (feof(dstin)) break;
		b2=buf[2];	//fgetc(dstin);
//		if (feof(dstin)) break;
		if (dstin->GetLength()==dstin->GetPosition()) break;

		dx=decode_record_dx(b0,b1,b2);
		dy=decode_record_dy(b0,b1,b2);
		flags=decode_record_flags(b2);
		//file stores distance in 0.1mm, stitches stored internally in pattern are mm.
		pattern->add_stitch_rel(double(dx)/10.0,double(dy)/10.0,flags);
		if(flags==STOP) co++;
	};
//	fclose(dstin);

	//TODO: Another good idea would be to verify header information here (dimensions, colors, etc)
	//      then warn if there is a discrepancy.
	buffer_add("Done reading stitches:",pattern->stitches);

#ifdef DEBUG_FILEOUT
	fprintf(fout,"Done reading: %d stitches\n",pattern->stitches);
	fclose(fout);
#endif

	//assign random colors
	srand((unsigned)time(NULL));
	for(;pattern->colors<co;) {
		pattern->add_color(RGB(rand()%256,rand()%256,rand()%256),"Random","");
	};
};

void dst_write(class pattern *pattern, const char *filename) {
	CFile dstout;

	if(!dstout.Open(filename,CFile::modeWrite)) {
		fprintf(stderr, "Error opening %s for write\n",filename);
		exit(-1);
	};

	dst_write(pattern,&dstout);

	dstout.Close();
};

void dst_write(class pattern *pattern, CFile *dstout) {
//	FILE *dstout;
	int xx,yy,dx,dy,flags;
	int negx,posx,negy,posy,st,co;
	int i;
	unsigned char b[3];
	int inserts=0;
	double fxx,fyy,fdx,fdy;
	char buf[100];

	if (pattern->stitches==0) {
		status("No file to save.");
		fprintf(stderr,"No file to save\n");
		return;
	};

//	dstout = fopen(filename,"w");
//	if (dstout==0) {
//		status("Error opening DST file for write:",filename);
//		return;
//		fprintf(stderr, "Error opening %s for write\n",filename);
//		exit(-1);
//	};
//	_setmode( _fileno( dstout ), _O_BINARY ); 

	//first pass through pattern calculating extents
	xx=yy=0; co=1; st=0; posx=negx=posy=negy=0;
	flags=NORMAL;
	for (i=0;flags!=END;i++) {
		if (i>pattern->stitches) break;
		dx=round(pattern->stitchlist[i].xx*10.0) - xx;
		dy=round(pattern->stitchlist[i].yy*10.0) - yy;
		// insert jump point if out of range.
		if (abs(dx)>211 || abs(dy)>211) {
			fxx=pattern->stitchlist[i-1].xx;	// use doubles to do insert calculation
			fyy=pattern->stitchlist[i-1].yy;
			fdx=pattern->stitchlist[i].xx - fxx;
			fdy=pattern->stitchlist[i].yy - fyy;

			int splits; // number of stitches to split overlength one into
			if (abs(dx)>abs(dy)) {
				splits = round(ceil(fabs(dx)/211.0));
			} else {
				splits = round(ceil(fabs(dy)/211.0));
			};
			for (int j=1;j<splits;j++) {
				pattern->add_stitch_abs(fxx+fdx*j/splits,fyy+fdy*j/splits,JUMP);
				//insert these jump stitches before i
				pattern->move_last_stitch(i+j-1);
				inserts++;
				//buffer_add("added jump stitch, xx=",pattern->stitchlist[i+j-1].xx);
				//buffer_add("                   yy=",pattern->stitchlist[i+j-1].yy);
			};
			//i--;
			//continue;
		};
		xx=round(pattern->stitchlist[i].xx * 10.0); // convert from mm to 0.1mm for file format
		yy=round(pattern->stitchlist[i].yy * 10.0);

		flags=pattern->stitchlist[i].flags;
		if (xx<negx) negx=xx;
		if (xx>posx) posx=xx;
		if (yy<negy) negy=yy;
		if (yy>posy) posy=yy;
		st++;
		if (flags==STOP) co++;

	};

	if (inserts>0) {
		buffer_add("DST format limitation (max dx,dy=211) required adding jump stitches to design: ",inserts);
	};
	//write header
	sprintf(buf,"LA:%-16s\x0d",pattern->get_variable("design_name"));
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"ST:%7d\x0d",st);
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"CO:%3d\x0d",co-1); // number of color changes, not number of colors!
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"+X:%5d\x0d",posx);
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"-X:%5d\x0d",abs(negx));
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"+Y:%5d\x0d",posy);
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"-Y:%5d\x0d",abs(negy));
	dstout->Write(buf,strlen(buf));

	int ax,ay,mx,my;
	char *pd;
	ax=ay=mx=my=0;
	ax=pattern->get_variable_int("ax");	// will return 0 if not defined
	ay=pattern->get_variable_int("ay");
	mx=pattern->get_variable_int("mx");
	my=pattern->get_variable_int("my");

	pd=pattern->get_variable("pd"); // will return null pointer if not defined
//	if (pd!=0) {buffer_add("PD_len ",(int)strlen(pd));};

	if (pd==0 || strlen(pd)!=6) {
		// pd is not valid, so fill in a default consisting of ******\0d
		//pd=(char *)malloc(10*sizeof(char*));
		//if (pd==0) {
		//	fprintf(stderr,"Failed to allocated PD in dst_write.\n");
		//	exit(-1);
		//};
		//pd[0]=pd[1]=pd[2]=pd[3]=pd[4]=pd[5]=42;		// * characters
		pd="******";
		//pd[6]='\0';
		//pd[6]=13;
		//pd[7]=26;
		//pd[8]=32;		// these taken from file exported by VIP Customizer
	};
	sprintf(buf,"AX:+%5d\x0d",ax);
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"AY:+%5d\x0d",ay);
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"MX:+%5d\x0d",mx);
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"MY:+%5d\x0d",my);
	dstout->Write(buf,strlen(buf));
	sprintf(buf,"PD:%6s\x0d",pd);
	dstout->Write(buf,strlen(buf));
//	for(i=0;i<9;i++) {	//PD is a random binary string and might contain \0.
//		fprintf(dstout,"%c",pd[i]);
//	};
	sprintf(buf,"\x1a");	// 0x1a is the code for end of section.
	dstout->Write(buf,strlen(buf));

	// pad out header to proper length
	for(i=125;i<512;i++) {
		sprintf(buf," ");
		dstout->Write(buf,strlen(buf));
	};

	//write stitches
	xx=yy=0;
	for (i=0;i<pattern->stitches;i++) {
		//convert from mm to 0.1mm for file format
		dx=round(pattern->stitchlist[i].xx*10.0) - xx;
		dy=round(pattern->stitchlist[i].yy*10.0) - yy;
		xx=round(pattern->stitchlist[i].xx*10.0);
		yy=round(pattern->stitchlist[i].yy*10.0);
		flags=pattern->stitchlist[i].flags;
		encode_record(b,dx,dy,flags);
		sprintf(buf,"%c%c%c",b[0],b[1],b[2]);
		dstout->Write(buf,strlen(buf));
	};

	sprintf(buf,"\x1a");	// finish file with a terminator character
	dstout->Write(buf,strlen(buf));
	//close file
//	fclose(dstout);
};