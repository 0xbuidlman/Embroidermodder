// embroidermodder.cpp : Defines the class behaviors for the application.
//
// This sourcecode file is a part of embroidermodder.
// This program is free software; you can use, redistribute, and/or modify it
// under the terms of the GNU General Puplic License (GPL) as published by
// the Free Software Foundation.  See the file license.txt for details.
// http://embroidermodder.sourceforge.net/
//

#include "stdafx.h"
#include "embroidermodder.h"

#include "AboutDialog.h"
#include "MainFrm.h"
#include "ChildFrm.h"
#include "pattern.h"
#include "EmbroideryDoc.h"
#include "EmbroideryView.h"
#include "messaging.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// The one and only CEmbroidermodderApp object

CEmbroidermodderApp theApp;


/////////////////////////////////////////////////////////////////////////////
// CEmbroidermodderApp message map

BEGIN_MESSAGE_MAP(CEmbroidermodderApp, CWinApp)
	//{{AFX_MSG_MAP(CEmbroidermodderApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CEmbroidermodderApp::OnFileOpen)
//	ON_COMMAND(ID_FILE_SAVE, CEmbroidermodderApp::OnFileSave)
//	ON_COMMAND(ID_FILE_SAVE_AS, CEmbroidermodderApp::OnFileSave)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEmbroidermodderApp construction

CEmbroidermodderApp::CEmbroidermodderApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// CEmbroidermodderApp initialization

BOOL CEmbroidermodderApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
//	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Embroidermodder"));

	int maxmru = 9;	// the number of MRU entries to allow.
	LoadStdProfileSettings(maxmru);  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CMultiDocTemplate* pDocTemplate1, *pDocTemplate2;
	pDocTemplate1 = new CMultiDocTemplate(
		IDR_EMBROIDERYTYPE,
		RUNTIME_CLASS(CEmbroideryDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CEmbroideryView));
	AddDocTemplate(pDocTemplate1);

	pDocTemplate2 = new CMultiDocTemplate(
		IDR_CSVTYPE,
		RUNTIME_CLASS(CEmbroideryDoc),
		RUNTIME_CLASS(CChildFrame), // custom MDI child frame
		RUNTIME_CLASS(CEmbroideryView));
	AddDocTemplate(pDocTemplate2);


	// create main MDI Frame window
	CMainFrame* pMainFrame = new CMainFrame;
	if (!pMainFrame->LoadFrame(IDR_MAINFRAME))
		return FALSE;
	m_pMainWnd = pMainFrame;

	// store statusbar pointer in theApp for future use
	status.StatusBar = (CStatusBarCtrl *) pMainFrame->GetMessageBar();

	// Enable drag/drop open
	m_pMainWnd->DragAcceptFiles();

	// Enable DDE Execute open
	EnableShellOpen();
	RegisterShellFileTypes(TRUE);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

	// The main window has been initialized, so show and update it.
	pMainFrame->ShowWindow(m_nCmdShow);
	pMainFrame->UpdateWindow();

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CEmbroidermodderApp idle time processing
// --maintains a queue of tasks, keeping track of the task type, and owner's 'this' pointer.
// --when idle time is available, run windows idle processing, then ours.
// --dequeue tasks that finish
// --keep requesting more processing until all tasks in queue are gone.
// --routine to flush all tasks for an owner should be called by owner's destructor.

BOOL CEmbroidermodderApp::OnIdle(LONG lCount) 
{
	// let default processing go first
	BOOL moreneeded = CWinApp::OnIdle(lCount);

	// TODO: Add your specialized code here and/or call the base class
	if (!moreneeded) {
		// do our processing
		// draw bitmaps, etc.
		moreneeded = execute_idletask();
		// return our moreneeded, rather than the default's
	};
	return moreneeded;
}

void CEmbroidermodderApp::queue_idletask(int task, void *owner) 
{
	// allocate a new idle queue if not already done.
	if (idle_queue==NULL) 
	{
		idle_queue_allocated=10;
		idle_queue_len=0;
		idle_queue=(struct idle_queue_entry *)malloc(sizeof(struct idle_queue_entry)*idle_queue_allocated);
		ASSERT(idle_queue != NULL);
	};
	// check to see if this task is already queued.
	for (int i=0;i<idle_queue_len;i++) 
	{
		if (idle_queue[i].owner==owner && idle_queue[i].task==task) return; // already queued
	};
	// if allocated queue space is full, allocate more space
	if (idle_queue_allocated < idle_queue_len+1) 
	{
		idle_queue_allocated+=10;
		idle_queue = (struct idle_queue_entry *)realloc(idle_queue, sizeof(struct idle_queue_entry)*idle_queue_allocated);
	};
	// add the task to the end of the queue.
	idle_queue[idle_queue_len].task=task;
	idle_queue[idle_queue_len].owner=owner;
	idle_queue_len++;
	return;
};

void CEmbroidermodderApp::flush_my_idletasks(void *owner) 
{
	// flush all tasks for an owner.  This is necessary when owner is destroyed.
	for (int i=0;i<idle_queue_len;i++)
	{
		if (idle_queue[i].owner==owner) 
		{
			// delete this task
			for (int j=i+1;j<idle_queue_len;j++) 
			{
				idle_queue[j-1]=idle_queue[j];
			};
			idle_queue_len--;
		};
	};
};

BOOL CEmbroidermodderApp::execute_idletask(void) 
{
	CEmbroideryView *view;
	if (idle_queue_len >0) 
	{
		switch(idle_queue[0].task) 
		{
		case IDLETASK_CREATE_BITMAP:
			view = (CEmbroideryView *)idle_queue[0].owner;
			// first, create the bitmap if it isn't already created.
			if ((view->usebitmap) && (view->bitmap_dc==NULL)) {
				view->bitmap_dc=view->create_bitmap(view->viewdimensions);
				view->bitmapcomplete=FALSE;
				view->bitmapstitched=0;
			};
			// next, if not complete, but created, then continue to render bitmap.
			if ((view->usebitmap) && (view->bitmap_dc!=NULL) && (!view->bitmapcomplete)) {
				view->paint_bitmap(view->bitmap_dc,100); // work on this for 100ms.
				if (!view->bitmapcomplete) {
#ifdef _DEBUG
					char buf[100];
					sprintf_s(buf,"Rendering : %d/%d",view->bitmapstitched,view->GetDocument()->pattern.stitches);
					theApp.status.set(buf);
#endif
					return(TRUE); // request more processing.
				};
			};
#ifdef _DEBUG
			if ((view->usebitmap) && (view->bitmap_dc!=NULL) && (view->bitmapcomplete)) {
				theApp.status.set("Render complete");
			};
#endif
			break;
		default:
			// don't know how to do this task
			break;
		};
		//view->GetDocument()->pattern.messages.add("Delete idle task.\n");
		// dequeue this task.
		for (int i=1; i<idle_queue_len; i++) 
		{
			idle_queue[i-1]=idle_queue[i];
		};
		idle_queue_len--;
	};
	return(idle_queue_len>0);
};


/////////////////////////////////////////////////////////////////////////////
// CEmbroidermodderApp message handlers

// File Open

void CEmbroidermodderApp::OnFileOpen()
{
	char FileFormatsString[]=FILE_FORMATS_STRING;
	CString newName;

	// prompt the user (with all document templates)
	CFileDialog fileDlg(TRUE, NULL, NULL, NULL, FileFormatsString);
	if (fileDlg.DoModal()==IDOK) {

		//CString extension = fileDlg.GetFileExt();
		newName = fileDlg.GetPathName();
		AfxGetApp()->OpenDocumentFile(newName);
	};
}

// App command to run the 'About' dialog
void CEmbroidermodderApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

