//embroidery_pattern.cpp
#include "stdafx.h"
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <math.h>
#include "dst.h"
#include "ksm.h"
#include "csv.h"
#include "pes.h"
#include "exp.h"
#include "pcs.h"
#include "embroidery_pattern.h"
#include "helpers.h"
#include "analyze.h"
#include "paint.h"

//number of stitches to allocate at a time
#define BLOCK_ALLOCATE_SIZE 1000

// Always initialize the pattern before use, or memory will not be allocated.
void embroidery_pattern::initialize_pattern (const char *design_name) {
	stitches=0;
	stitchlist=0;
	colors=0;
	this->design_name=stralloccopy(design_name);

	allocated_stitches=BLOCK_ALLOCATE_SIZE;
	stitchlist = (struct stitch *)malloc(sizeof(struct stitch) * allocated_stitches);
	if (stitchlist==0) {
		fprintf(stderr,"ERROR: failed to alloc %d stitchlist bytes in initialize_pattern().\n",sizeof(struct stitch) * allocated_stitches);
		exit(-1);
	};

	allocated_colors=64;
	colorlist = (struct color*)malloc(sizeof(struct color) * allocated_colors);
	if (colorlist==0) {
		fprintf(stderr,"ERROR: failed to alloc %d color bytes in initialize_pattern().\n",sizeof(struct color) * allocated_colors);
		exit(-1);
	};
};

int embroidery_pattern::add_color (COLORREF rgb, const char *description, const char *catalog_number, int colNum) {
	if (allocated_colors<colors+1) {
		allocated_colors+=64;
		colorlist = (struct color *)realloc(colorlist, sizeof(struct color) * allocated_colors);
	};
	if (colorlist==0) {
		fprintf(stderr,"ERROR: failed to realloc %d bytes in add_color().\n",sizeof(struct stitch) * allocated_stitches);
		exit(-1);
	};
	colorlist[colors].rgb=rgb;
	colorlist[colors].description=stralloccopy(description);
	colorlist[colors].catalog_number=stralloccopy(catalog_number);	colorlist[colors].colorNumber=colNum;
//	buffer_add("Colors=",colors);
//	buffer_add("R",GetRValue(rgb));
//	buffer_add("G",GetGValue(rgb));
//	buffer_add("B",GetBValue(rgb));
	colors++;
	return(colors);
};

// Three routines to add a stitch to the pattern depending on format...
int embroidery_pattern::add_stitch_abs (double x, double y, int flags) {
	if (allocated_stitches<stitches+1) {
		allocated_stitches+=BLOCK_ALLOCATE_SIZE;
		stitchlist = (struct stitch *)realloc(stitchlist, sizeof(struct stitch) * allocated_stitches);
	};
	if (stitchlist==0) {
		fprintf(stderr,"ERROR: failed to realloc %d bytes in add_stitch_abs().\n",sizeof(struct stitch) * allocated_stitches);
		exit(-1);
	};
	stitchlist[stitches].xx=x;
	stitchlist[stitches].yy=y;
	stitchlist[stitches].flags=flags;
	stitches++;
	return(stitches);
};

int embroidery_pattern::add_stitch_rel (double dx, double dy, int flags) {
	double x,y;
	if (stitches>0) {
		x = stitchlist[stitches-1].xx + dx;
		y = stitchlist[stitches-1].yy + dy;
	} else { // the list is empty so assume starting location is 0,0
		x = dx;
		y = dy;
	};
	return(add_stitch_abs(x,y,flags));
};

int embroidery_pattern::add_stitch_copy (struct stitch src) {
	return(add_stitch_abs(src.xx,src.yy,src.flags));
};

// Delete a stitch from the middle of the list.
int embroidery_pattern::delete_stitch (int number) {
	int i;
	for (i=number; i<stitches; i++) {
		stitchlist[i]=stitchlist[i+1];
	};
	stitches--;
	return(stitches);
};

// Move a stitch from the end of the list to a position.
// To insert, add stitch normally, then move it to position.
int embroidery_pattern::move_last_stitch (int number) {
	int i;
	struct stitch temp;

	temp=stitchlist[stitches-1];
	for (i=stitches-1; i>number; i--) {
		stitchlist[i]=stitchlist[i-1];
	};
	stitchlist[number]=temp;
	return(stitches);
};

// A simple list of the stitches, handy for debugging.
void embroidery_pattern::print_stitchlist (char *filename) {
	double xx,yy,dx,dy;
	int flags;
	int i;
	FILE *fout;
	double length;

	fout = fopen(filename,"w");
	if (fout==0) {
		fprintf(stderr, "Error opening %s for write\n",filename);
		//exit(-1);
	};

	xx=yy=0.0;
	for (i=0;i<stitches;i++) {
		dx=stitchlist[i].xx - xx;
		dy=stitchlist[i].yy - yy;
		xx=stitchlist[i].xx;
		yy=stitchlist[i].yy;
		flags=stitchlist[i].flags;
		length=sqrt(dx * dx + dy * dy);
		fprintf(fout," %7d: %6.2lf,%6.2lf (%6.2lf) (%6d,%6d) : ",i+1,dx,dy,length,xx,yy);
		switch(flags) {
		case NORMAL:
			fprintf(fout,"Normal Stitch\n");
			break;
		case END:
			fprintf(fout,"End\n");
			break;
		case JUMP:
			fprintf(fout,"Jump Stitch\n");
			break;
		case STOP:
			fprintf(fout,"Stop/Color\n");
			break;
		default:
			fprintf(fout,"Unknown\n");
			break;
		};
	};

	fclose (fout);
//	analysis_dump(this,"analysis.txt");
};

// read or write files using .DST file format
void embroidery_pattern::read_dst(const char *filename) {
	dst_read(this,filename);
};
void embroidery_pattern::write_dst(const char *filename) {
	dst_write(this,filename);
};

// read or write files using .CSV file format
void embroidery_pattern::read_csv(const char *filename) {
	csv_read(this,filename);
};
void embroidery_pattern::write_csv(const char *filename) {
	csv_write(this,filename);
};
void embroidery_pattern::read_pes(const char *filename) {
	pes_read(this,filename);
};void embroidery_pattern::read_exp(const char *filename) {
	exp_read(this,filename);
};
void embroidery_pattern::write_exp(const char *filename) {
	exp_write(this,filename);
};
void embroidery_pattern::read_pcs(const char *filename) {
	pcs_read(this,filename);
};

void embroidery_pattern::read_ksm(const char *filename) {
	ksm_read(this,filename);
};

// Very simple scaling of the x and y axis for every point.
// Doesn't insert or delete stitches to preserve density.
void embroidery_pattern::scale_pattern (double scale) {
	int i;
	for (i=0;i<stitches;i++) {
		stitchlist[i].xx=stitchlist[i].xx*scale;
		stitchlist[i].yy=stitchlist[i].yy*scale;
	};
};

void embroidery_pattern::statistics (void) {
	int colors=1;
	int real_stitches=0;
	int jump_stitches=0;
	int unknown_stitches=0;
	double minx=0,maxx=0,miny=0,maxy=0;
	double min_stitchlength=999.0;
	double max_stitchlength=0.0;
	double total_stitchlength=0.0;
	int number_of_minlength_stitches=0;
	int number_of_maxlength_stitches=0;
	
//	FILE *fout;
	int i;
	double xx=0,yy=0;
	double dx=0,dy=0;
	double length=0.0;

	if (stitches ==0) {
		buffer_add("No design loaded\n");
		return;
	};

	for (i=0;i<stitches;i++) {
		dx=stitchlist[i].xx-xx;
		dy=stitchlist[i].yy-yy;
		xx=stitchlist[i].xx;
		yy=stitchlist[i].yy;
		length=sqrt(dx * dx + dy * dy);
		if (i>0 && stitchlist[i-1].flags!=NORMAL) length=0.0;	//can't count first normal stitch;
		switch(stitchlist[i].flags) {
			case NORMAL:
				real_stitches++;
				if(length>max_stitchlength) {max_stitchlength=length; number_of_maxlength_stitches=0;};
				if(length==max_stitchlength) number_of_maxlength_stitches++;
				if(length>0 && length<min_stitchlength) {min_stitchlength=length; number_of_minlength_stitches=0;};
				if(length==min_stitchlength) number_of_minlength_stitches++;
				total_stitchlength+=length;
				if(xx<minx) minx=xx;
				if(xx>maxx) maxx=xx;
				if(yy<miny) miny=yy;
				if(yy>maxy) maxy=yy;
				break;
			case JUMP:
				jump_stitches++;
				break;
			case STOP:
				colors++;
				break;
			case END:
				break;
			default:
				unknown_stitches++;
				break;
		};
	};

	//second pass to fill bins now that we know max stitch length
#define NUMBINS 10
	int bin[NUMBINS+1];
	for (i=0;i<=NUMBINS;i++) {
		bin[i]=0;
	};

	for (i=0;i<stitches;i++) {
		dx=stitchlist[i].xx-xx;
		dy=stitchlist[i].yy-yy;
		xx=stitchlist[i].xx;
		yy=stitchlist[i].yy;
		if (i>0 && stitchlist[i-1].flags==NORMAL && stitchlist[i].flags == NORMAL) {
			length=sqrt(dx * dx + dy * dy);
			bin[int(floor(NUMBINS*length/max_stitchlength))]++;
		};
	};

	/*
	if(filename!= NULL) {
	fout = fopen(filename,"w");
	if (fout==0) {
		fprintf(stderr, "Error opening %s for write\n",filename);
		exit(-1);
	};
	fprintf(fout,"Design name: %s\n",design_name);
	fprintf(fout,"Number of stitch entries: %d\n",stitches);
	fprintf(fout,"  Real stitches: %d\n",real_stitches);
	fprintf(fout,"  Jump stitches: %d\n",jump_stitches);
	fprintf(fout,"  Colors: %d\n",colors);
	fprintf(fout,"  Unknown stitches: %d\n",unknown_stitches);
	fprintf(fout,"Design width x height = %.1lf x %.1lf\n",maxx-minx,maxy-miny);
	fprintf(fout,"Center of design = %.1lf,%.1lf\n",(maxx+minx)/2.0,(maxy+miny)/2.0);
	fprintf(fout,"Total length of stitches: %.1lf\n",total_stitchlength);
	fprintf(fout,"Maximum stitch length: %.2lf (%d at this length)\n",max_stitchlength, number_of_maxlength_stitches);
	fprintf(fout,"Minimum stitch length: %.2lf (%d at this length)\n",min_stitchlength, number_of_minlength_stitches);
	fprintf(fout,"Average length of stitches: %.2lf\n",total_stitchlength/real_stitches);
	fprintf(fout,"Stitch length distribution:\n");
	for (i=0;i<NUMBINS-1;i++) {
		fprintf(fout," %6.2lf-%6.2lf == %d\n",i * max_stitchlength/NUMBINS,(i+1) * max_stitchlength/NUMBINS,bin[i]);
	};
	fprintf(fout," %6.2lf-%6.2lf == %d\n",i * max_stitchlength/NUMBINS,(i+1) * max_stitchlength/NUMBINS,bin[i]+bin[i+1]);
	fclose(fout);
	};
	*/
	char buf[1000];
	buffer_clear();
	sprintf(buf,"Design name: %s\n",design_name);
	buffer_add(buf);
	sprintf(buf,"Number of stitch entries: %d\n",stitches);
	buffer_add(buf);
	sprintf(buf,"  Real stitches: %d\n",real_stitches);
	buffer_add(buf);
	sprintf(buf,"  Jump stitches: %d\n",jump_stitches);
	buffer_add(buf);
	sprintf(buf,"  Colors: %d\n",colors);
	buffer_add(buf);
	sprintf(buf,"  Unknown stitches: %d\n",unknown_stitches);
	buffer_add(buf);
	sprintf(buf,"Design width x height = %.1lf x %.1lf\n",maxx-minx,maxy-miny);
	buffer_add(buf);
	sprintf(buf,"Center of design = %.1lf,%.1lf\n",(maxx+minx)/2.0,(maxy+miny)/2.0);
	buffer_add(buf);
	sprintf(buf,"Total length of stitches: %.2lf\n",total_stitchlength);
	buffer_add(buf);
	sprintf(buf,"Maximum stitch length: %.2lf (%d at this length)\n",max_stitchlength, number_of_maxlength_stitches);
	buffer_add(buf);
	sprintf(buf,"Minimum stitch length: %.2lf (%d at this length)\n",min_stitchlength, number_of_minlength_stitches);
	buffer_add(buf);
	sprintf(buf,"Average length of stitches: %.2lf\n",total_stitchlength/real_stitches);
	buffer_add(buf);
	sprintf(buf,"Stitch length distribution:\n");
	buffer_add(buf);
	for (i=0;i<NUMBINS-1;i++) {
		sprintf(buf," %6.2lf-%6.2lf == %d\n",i * max_stitchlength/NUMBINS,(i+1) * max_stitchlength/NUMBINS,bin[i]);
		buffer_add(buf);
	};
	sprintf(buf," %6.2lf-%6.2lf == %d\n",i * max_stitchlength/NUMBINS,(i+1) * max_stitchlength/NUMBINS,bin[i]+bin[i+1]);
	buffer_add(buf);
	
};

void embroidery_pattern::create_test(void) {
	initialize_pattern("TEST7");
	add_stitch_abs( 0.0, 0.0,JUMP);
	add_stitch_abs( 3.0, 3.0,JUMP);
	add_stitch_abs( 3.0, 3.0,NORMAL);
	add_stitch_abs(-3.0, 3.0,NORMAL);
	add_stitch_abs(-3.0,-3.0,NORMAL);
	add_stitch_abs( 3.0,-3.0,NORMAL);
	add_stitch_abs( 3.0, 3.0,NORMAL);
	add_stitch_abs(-3.0, 3.0,NORMAL);
	add_stitch_abs( 0.0, 0.0,JUMP);
	add_stitch_abs( 0.0, 0.0,END);
	add_color(RGB(rand()%256,rand()%256,rand()%256),"Random","",1);
	//print_stitchlist("test7_stitchlist.txt");
	//write_dst("test7.dst");
};

struct lfRECT embroidery_pattern::get_dimensions(void) {
	struct lfRECT dim;
	int i; 
	double xx,yy;
	dim.top=dim.bottom=dim.left=dim.right=0;

	for (i=0;i<stitches;i++) {
		xx=stitchlist[i].xx;
		yy=stitchlist[i].yy;
		if(xx<dim.left)   dim.left=xx;
		if(xx>dim.right)  dim.right=xx;
		if(yy<dim.top)    dim.top=yy;
		if(yy>dim.bottom) dim.bottom=yy;
	};
	return (dim);
};

void embroidery_pattern::calculate_angles(void) {
	double xx,yy,dx,dy;
	int flags;
	int i;
	xx=yy=0.0;

	double pi = 3.1415926535;

	for (i=0;i<stitches;i++) {
		//initialize all to -999 to indicate invalid.
		stitchlist[i].a= -999;
		stitchlist[i].da=-999;
		stitchlist[i].l= -999;
	};

	for (i=0;i<stitches;i++) {
		dx=stitchlist[i].xx - xx;
		dy=stitchlist[i].yy - yy;
		xx=stitchlist[i].xx;
		yy=stitchlist[i].yy;
		flags=stitchlist[i].flags;
		stitchlist[i].l = sqrt(dx * dx + dy * dy); // length into this point
		
		if (flags!=JUMP) {
			stitchlist[i].a = atan2(dy,dx) *180.0/pi;	// angle of line into this point
			//stitchlist[i].l = sqrt(dx * dx + dy * dy); // length into this point
			if (stitchlist[i].l==0) {
				stitchlist[i].a=-999;
			};
		};
	};
	for (i=0;i<stitches-1;i++) {
		if (stitchlist[i].a !=-999 && stitchlist[i+1].a !=-999) {
			stitchlist[i].da = stitchlist[i+1].a-stitchlist[i].a;
		};
	};
};
